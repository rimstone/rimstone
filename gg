#!/bin/bash
#SPDX-License-Identifier: Apache-2.0
#Copyright 2018-2025 Gliim LLC.  
#Licensed under Apache License v2. See LICENSE file.
#On the web http://golf-lang.com/ - this file is part of Golf framework.

#variable names for Golf start with GG_ (GG_C_ being compiling-related) and _ (internal)

#
#
#make script for Golf application
#
#

#
#Set one or the other
#
#_BETA=""

#enable "extended globs" (such as "parameter expansion" or ${!X}
shopt -s extglob nullglob globstar
#display error context if golf has a shell error, source file bash only
set -eE -o functrace
trap 'echo "Error: status $?, $(caller), line ${BASH_SOURCE[0]}/${LINENO}"' ERR
function exit_s() {
    #remove trap so we don't have a message if we're exiting on purpose
    trap - ERR
    exit $1
}
#
#
#
#Emitting error messages
#
#
#
function error() {
#$1 is message
    echo -e "** Error: $1" 1>&2
    exit_s -1
}

#cannot run as run as it might mess up permissions. 
if [[ $EUID -eq 0 ]]; then error "You cannot run gg as root or sudo";  fi


export GG_USER=$(whoami)
#make sure HOME is available, some apps wipe it out like apache setenv
if [ "$HOME" == "" ]; then
    HOME=$(eval echo ~$GG_USER)
fi
export HOME
#location of Golf data
export GG_DATA="$HOME/.golf"
#make sure  local directory exists, installation should have created it
if [ ! -d "$GG_DATA" ]; then
    mkdir -p $GG_DATA/src
    if [ ! -d "$GG_DATA" ]; then
        error "Cannot create directories under $GG_DATA, please make sure it can be created and is writeable"
    fi
fi


#
#
#DO NOT change these values, they are changed here by Makefile per platform when make install is done
export GG_LIBRARY_PATH="$GG_DATA/lib"
. "$GG_LIBRARY_PATH"/sys
#find out where this script runs from (i.e. where 'gg' actually is, minus /usr/bin)
#end of DO-NOT-change
#
#

#by default, make is silent (except for messages we emit). For debugging, use -e to see everything that's going on (this shows golf execution too!)
GG_SHOW_MAKE="-s"


#get gcc version
export GG_C_GCC
read -r GG_C_GCC < <(gcc --version)

export GG_C_RESTPATH=""
export GG_C_MAXUPLOAD="25000000"
export GG_C_CLIENT_TOUT="5"
export GG_C_CPUS=$(nproc)
if (( GG_C_CPUS < 1 )); then
    export GG_C_CPUS="1"
fi
export GG_C_MAXERRORS="5"
export GG_C_DEBUG="0" # not by default
export GG_C_DEVEL="1" # devel by default


#defaults for quick install
_PROXYPORT="80"

#display Golf usage
#
#Internal options that may go away:
#--asan build with ASAN
#--asan-opt print out ASAN option to prefix the execution with, also works with prefix mgrg for better coverage of SERVICE program
#--prof build with gprof
#--debug is internal option that executes the code in a manner that facilitates Golf debugging (it's an add-on to --devel)
#
function use_message() {
    echo "Usage: $0  OPTIONS 
OPTIONS:

-k <app> create application <app> with default settings
-c       clean make artifacts for a rebuild
-v       show version
-s       show detailed execution (script tracing)
-e N     show last N program backtraces
-o       show documentation directory
-l       show library directory
-m       setup syntax highlighting for Vim
-u       substitute environment variables in stdin
-r       display shell commands to run a program
             --req=\"/<request name><url payload>\"
             --method=\"<request method>\"
             --content=\"<file name>\"
             --content-type=\"<content type>\"
             --exec
             --app=\"application path\" 
             --service
             --remote=\"server IP:port\"
             --socket=\"socket path\"
             --arg=\"arguments\"
-q       build application
             --db=\"mariadb:<db name>|postgres:<db name> ...\" 
             --lflag=<linker flags> 
             --cflag=<c flags> 
             --c-lines 
             --posix-regex
             --devel | --release
             --maxupload=<max upload size>
             --client-timeout=<timeout>
             --path=\"/some/path\"
             --max-errors=<max errors>
             --plain-diag
             --optimize-memory
             --parallel=<compiling threads>
             --public
             --single-file
             --exclude-dir=<dir list>
             --ignore-warn
             --verbose
-i       display build flags for FastCGI client
             --include
                 displays C compile flags
             --link
                 displays C linking flags
--man    display all Golf topic available (--man all)
             or view a topic (--man <topic>)
-h       this help
Type 'man gg' for more information.
"
}


#process all command-line options
function main() {



#list of Golf options for getop
_OPT_STATUS="0"
#do NOT use optional :: args - they must always be used as -e3 for example - there can be no space. This is awkward and unwieldy.
_opts=$(getopt -a -n $0 -o k:e:,q,o,l,m,i,h,c,v,s,u,r --long verbose,ignore-warn,exclude-dir:,man:,single-file,public,parallel:,db:,lflag:,cflag:,arg:,plain-diag,optimize-memory,posix-regex,asan,asan-opt,prof,content:,content-type:,silent-header,service,remote:,socket:,app:,path:,c-lines,debug,devel,release,req:,exec,method:,maxupload:,client-timeout:,max-errors:,include,link,safe -- "$@") || _OPT_STATUS=$?
if [ $_OPT_STATUS -ne 0 ]; then
    use_message 1>&2
    exit_s -1
fi

#init flags used to emit helpful messages
_DEVOPT=0
_DO_QUICK=0

#if nothing at all passed that is valid: make golf application - that is just 'golf'
    eval set -- "$_opts"
    while true; do 
    case "$1" in 
        --c-lines  )
            export GG_C_SKIPLINES="1"
            _DEVOPT=1
            shift 
            ;;
        --public  )
            export GG_C_PUBLIC="1"
            _DEVOPT=1
            shift 
            ;;
        --single-file  )
            export GG_C_SINGLE_FILE="1"
            _DEVOPT=1
            shift 
            ;;
        --man  )
            if [ "$2" == "all" ]; then
                GGMAN=($GG_DATA/man/man2/*.2gg) 2>/dev/null || true
                for i in ${GGMAN[*]}; do i=${i##*/};echo ${i%.*}; done | more
            else
                if [ ! -f "$GG_DATA/man/man2/$2.2gg" ]; then
                    error "Man page [$2] does not exist. Use '--man all' to view all pages"
                fi
                cat $GG_DATA/man/man2/$2.2gg |preconv|groff -man -T utf8 -P -c|more
            fi
            shift 2
            exit 0
            ;;
        --verbose  )
            export GG_C_SHOW="1"
            _DEVOPT=1
            shift 
            ;;
        --ignore-warn  )
            export GG_C_IGNORE_WARN="1"
            _DEVOPT=1
            shift 
            ;;
        --release  )
            export GG_C_DEVEL="0"
            _DEVOPT=1
            shift 
            ;;
        --devel  )
            export GG_C_DEVEL="1"
            _DEVOPT=1
            shift 
            ;;
        --debug  )
            export GG_C_DEBUG="1"
            _DEVOPT=1
            shift 
            ;;
        --asan-opt  )
            echo "ASAN_OPTIONS=log_path=asan:halt_on_error=0"
            exit 0
            ;;
        --prof  )
            export GG_C_PROF="1"
            _DEVOPT=1
            shift 
            ;;
        --asan  )
            export GG_C_ASAN="1"
            _DEVOPT=1
            shift 
            ;;
#gg -r to talk to service (local socket by default)
        --service  )
            _REQ_SRV="1"
            shift 
            ;;
        --path  )
            export GG_C_RESTPATH="$2"
            _DEVOPT=1
            shift 2
            ;;
        --client-timeout  )
            export GG_C_CLIENT_TOUT="$2"
            _DEVOPT=1
            shift 2
            ;;
        --maxupload  )
            export GG_C_MAXUPLOAD="$2"
            _DEVOPT=1
            shift 2
            ;;
        --max-errors  )
            export GG_C_MAXERRORS="$2"
            _DEVOPT=1
            shift 2
            ;;
        --posix-regex  )
            export GG_C_POSIXREGEX="1"
            _DEVOPT=1
            shift
            ;;
        --cflag  )
            export GG_C_CFLAGS="$2"
            _DEVOPT=1
            shift 2
            ;;
        -u )
#subst env vars from stdin to stdout
            "$GG_LIBRARY_PATH"/v1 -envsub
            exit 0
            ;;
        -e )
#display last N errors from backtrace
            _SHOWERROR="$2"
            shift 2
            ;;
        --lflag  )
            export GG_C_LFLAGS="$2"
            _DEVOPT=1
            shift 2
            ;;
        --content-type  )
#content type
            _REQ_CONTENT_TYPE="$2"
            shift 2
            ;;
        --content  )
            #content file (read from file)
            _REQ_CONTENT="$2"
            shift 2
            ;;
        --silent-header )
#silent-header for --exec
            _REQ_SILENT_HEADER=1
            shift 1
            ;;
        --arg  )
#arguments for command-line execution
            _REQ_ARG="$2"
            shift 2
            ;;
        --method  )
#request method (GET, POST...)
            _REQ_METHOD="$2"
            shift 2
            ;;
        --exec  )
#request execute
            _REQ_EXEC="1"
            shift 1
            ;;
        --app  )
#app name (script name) for -r
            _REQ_APP="$2"
            shift 2
            ;;
        --socket  )
#socket for -r --exec
            _REQ_SOCK="$2"
            shift 2
            ;;
        --remote  )
#serverIP:port for -r --exec
            _REQ_IP="$2"
            shift 2
            ;;
        --req  )
#request name+payload 
            _REQ_URL="$2"
            shift 2
            ;;
        -k  )
#create new application
            _NEWAPP="1"
            _NAME="$2"
            shift 2
            ;;
        -r  )
#display bash to run command-line program
            _COMMRUN="1"
            shift
            ;;
        -h  )
#help message
            use_message
            shift
            exit
            ;;
        -m )
#Vim highlighting
            _DO_HIGHLIGHT="1"
            shift 
            ;;
        --link )
#display FastCGI link
            _DO_CLIENT_LINK="1"
            shift 
            ;;
        --include )
#display FastCGI include
            _DO_CLIENT_INCLUDE="1"
            shift 
            ;;
        -i )
#display FastCGI client flags
            _DO_CLIENT="1"
            shift 
            ;;
        -q )
#quick setup
            _DO_QUICK="1"
            shift 
            ;;
        --exclude-dir )
#exclude directories for compilation
            GG_DIR_EXCLUDE="$2"
            _DEVOPT=1
            shift 2
            ;;
        --parallel )
#parallel compilation override
            CPUS="$2"
            if (( CPUS >= 1 && CPUS < GG_C_CPUS * 3 )); then
                export GG_C_CPUS=$CPUS
            fi
            _DEVOPT=1
            shift 2
            ;;
        --db )
#db vendor
            _ALLDB="$2"
            _DEVOPT=1
            shift 2
            ;;
        -c )
#clean the project's temp and object files. This is to be able to fully recompile the project afterwards.
            _DO_CLEAN="1"
            shift 
            ;;
        -l )
#show lib directory
            echo "$GG_LIBRARY_PATH"
            shift 
            exit
            ;;
        -o )
#show documentation directory
            docdir
            shift 
            exit
            ;;
        -s )
#display golf script's execution in detail
            export GG_SHOW_MAKE=
            set -x
#this flag is if -s applies only to -q (i.e. compilation)
#            _DEVOPT=1
            shift 
            ;;
        -v )
#display version of Golf
            gg_version
            exit
            ;;
        -- ) 
            shift 
            break
            ;;
        * ) 
            use_message 1>&2
            exit_s -1
        esac
    done

    if [ "$GG_C_DEVEL" == "1" ]; then
        GDEST="devel"
    else
        if [ "$GG_C_DEBUG" == "1" ]; then
            error "Cannot use --debug with release build"
        fi
        GDEST="release"
    fi

#we always first check if application is being created, so then afterwards it can be made etc; thus we don't exit 
    if [ "$_NEWAPP" == "1" ]; then
        if [ "$_NAME" == "" ]; then
            error "You must specify application name you wish to create"
        fi
        check_name "$_NAME" "application name"
        #make ./golf for
        ECODE=0
        mgrg -i -u $(whoami) $_NAME || ECODE=$?
        #exit immediately if not successful
        if [ "$ECODE" != "0" ]; then
            exit_s $ECODE
        fi
        #otherwise check if we want to do -q too
        if [ "$_DO_QUICK" != "1" ]; then
            exit_s $ECODE
        fi
    fi

#handle client fastcgi app building
    if [[ "$_DO_QUICK" == "1" && "$_DO_CLIENT" == "1" ]]; then
        error "Cannot use both -i and -q options. Use one or the other"
    fi
    if [ "$_DO_CLIENT" == "1" ]; then
        show_client_bld
        exit 0
    fi

#internal: Address Sanitizer only with debug
    if [[ "$GG_C_ASAN" == "1" && "$GG_C_DEVEL" != "1" ]]; then
        error "In order to use ASAN, you must use --devel option"
    fi

#something extra and unexpected, complain about it, probably an error
    if [ "$1" != "" ]; then
        error "Unknown input [$1]"
    fi

#before app name checking b/c it doesn't have anything to do with it
    if [ "$_DO_HIGHLIGHT" != "" ]; then
        setup_highlighting
        exit 0
    fi

#can run this from anywhere if has --req and (--service or --app), otherwise must be in app dir
if [[ "$_COMMRUN" != "" && ("$_REQ_APP" != "" ||  ("$_REQ_SRV" != "" && ("$_REQ_IP" != "" || "$_REQ_SOCK" != "")))  ]]; then
        _TOEXEC=".gg_reqexec"
        #need || true to remove temp file
        show_run_program || true
        rm -f "$_TOEXEC"
        exit 0
    fi

#application name created with mgrg in .vappname, which must exist
    if [ -f ".vappname" ]; then
        #this is special $() which doesn't create subshell, but just reads contents into a variable
        export GG_C_NAME=$(<.vappname)
    else
        error "Golf application was not created yet. Please use 'gg- k' to create an application first"
    fi
    check_name "$GG_C_NAME" "application name"
    export GG_BLD=$GG_DATA/apps/$GG_C_NAME/.bld
    export GG_BLD0=$GG_BLD/.bld
    export GG_H="$GG_DATA/apps/$GG_C_NAME"
    export GG_A="$GG_H/app"

#THEN perform any actions

#check for source only if compiling or cleaning up
    if [[ "$_DO_QUICK" == "1" || "$_DO_CLEAN" == "1" ]]; then
        GLIST_L=(*.golf) 2>/dev/null || true
        GLIST_C=${#GLIST_L[@]}
        if [ "$GLIST_C" == "0" ]; then
            error "No Golf source source code found."
        fi
        if [[ ! -d "$GG_A" || ! -d "$GG_BLD" ]]; then
            error "Golf application [$GG_C_NAME] does not exist. Use 'gg -k' to create it."
        fi
    fi
    if [[ "$_DO_QUICK" == "0" && "$_DEVOPT" == "1" ]]; then
        error "Use -q if you intend to make the application."
    fi

    if [ "$_SHOWERROR" != "" ]; then
        showerr $_SHOWERROR
        exit 0
    fi

    if [ "$_COMMRUN" != "" ]; then
        _TOEXEC="$GG_BLD/.reqexec"
        #this is if running gg -r from outside source directory
        if [ ! -f $GG_BLD/.blds ]; then
            error "Cannot find application, use --app option."
        fi
        . $GG_BLD/.blds
        show_run_program
        exit 0
    fi

#perform cleaning FIRST. Must 
    if [ "$_DO_CLEAN" == "1" ]; then
        gg_clean
        exit 0
    fi


#perform any actions
#autoapp make app automatically. It exits at its end
    if [ "$_DO_QUICK" == "1" ]; then 
#build app
        autoapp
    fi


#these are 'in-conclusion' actions, they happen LAST
    error "No action specified."
}




#
#
#Functions used in processing
#
#


#
#
#
#Show flags for client FastCGI app building. 
#
#
#
function show_client_bld() {
#if neither --cflag nor --lflag specified, print out both
    if [[ "$_DO_CLIENT_INCLUDE" != "1" &&  "$_DO_CLIENT_LINK" != "1" ]]; then
        _DO_CLIENT_INCLUDE=1
        _DO_CLIENT_LINK=1
    fi
#print the flag asked for, if both, place them on the same line
    if [ "$_DO_CLIENT_INCLUDE" == "1" ]; then
        echo -n "-I$HOME/.golf/include "
    fi
    if [ "$_DO_CLIENT_LINK" == "1" ]; then
        echo -n "-L$GG_LIBRARY_PATH/$GDEST -lgolfcli -Wl,--rpath=$GG_LIBRARY_PATH/$GDEST "
    fi
    #use LTO for building clients
    echo "-flto=auto "
}

#
#
#
#Setup keyword highlighting for Vim
#
#
#
function setup_highlighting() {
    mkdir -p $HOME/.vim
    mkdir -p $HOME/.vim/syntax
    mkdir -p $HOME/.vim/indent
    cp $GG_LIBRARY_PATH/golf.vim $HOME/.vim/syntax/golf.vim
    cp $GG_LIBRARY_PATH/golf_indent.vim $HOME/.vim/indent/golf.vim
#set .golf file type to use golf.vim above
    _VICOMM="autocmd BufRead,BufNewFile *.golf set filetype=golf"
    if [ ! -f "$HOME/.vimrc" ]; then
        echo "$_VICOMM" > $HOME/.vimrc
    else
        E=0; grep -F "$_VICOMM" $HOME/.vimrc >/dev/null || E=$?
        if [ "$E" != "0" ]; then
            echo "$_VICOMM" >> $HOME/.vimrc
        fi
    fi
#make sure syntax is on
    _VICOMM="filetype indent on"
    E=0; grep -F "$_VICOMM" $HOME/.vimrc >/dev/null||E=$?
    if [ "$E" != "0" ]; then
        echo "$_VICOMM" >> $HOME/.vimrc
    fi
#make sure syntax is on
    _VICOMM="syntax on"
    E=0; grep -F "$_VICOMM" $HOME/.vimrc >/dev/null||E=$?
    if [ "$E" != "0" ]; then
        echo "$_VICOMM" >> $HOME/.vimrc
    fi
}


#
#
#Get last part of a path
#Fast, without using subshells
#
#
function last_path_seg() {
    P="$1"
    P="${P%/}"          
    GG_LAST_PATH_SEG="${P##*/}"
}


#
#
#
#Display bash to run command-line program
#
#
#
function show_run_program() {
    #GG_C_RESTPATH is set and restored from .blds file, so even if it's not in gg -r, it was in gg -q
    #and here it is now - this is so we don't have to remember the path set if we're in development build directory
    if [ "$GG_C_RESTPATH" == "" ];  then
        _APATH="/$GG_C_NAME"
    else
        #remove any trailing / with ${X%%<pattern>}
        _APATH="${GG_C_RESTPATH%%+(/)}"
    fi
#--app overrides current working directory application above
    if [ "$_REQ_APP" != "" ]; then
        _APATH="$_REQ_APP"
    fi
#get app name from _APATH, it's the last path segment, since _APATH is application path
    last_path_seg "$_APATH"
    _ANAME="$GG_LAST_PATH_SEG"
    _REQ_PATH="/<request name><url payload>"
    _REQ_QUERY="<request query>"
    if [ "$_REQ_URL" != "" ]; then
        if [[ ! "$_REQ_URL" =~ ^/.*$ ]]; then
            error "Request path (--req) must be a path (it must start with a forward slash)"
        fi
        if [[ "$_REQ_URL" =~ ^.*\?.*$ ]]; then
            #fast parsing of path without using subshells
            IFS='?' read -ra PQ <<< "$_REQ_URL"
            _REQ_PATH="${PQ[0]}"
            _REQ_QUERY="${PQ[1]}"
        else
            _REQ_PATH="$_REQ_URL"
            _REQ_QUERY=""
        fi
    fi
    if [ "$_REQ_METHOD" == "" ]; then
        _REQ_METHOD="GET"
    fi
    _CONT=""
    _CONTL=""
    _CONTT="export CONTENT_TYPE="
    _SHEADER="export GG_SILENT_HEADER=no"
    if [ "$_REQ_SILENT_HEADER" == "1" ]; then
        _SHEADER="export GG_SILENT_HEADER=yes"
    else
#unset" means it's not set in bash. This is used to override any already exising yes or no in the user's environment. If that was no or yes
#then it would control, and we don't want that. Explicit silent-header will set to yes, but if not set, then server will decide what to do because
#now we have -z flag in mgrg that can do that or a request can use silent-header.
        _SHEADER="unset GG_SILENT_HEADER
export GG_SILENT_HEADER"
    fi
    if [[ "$_REQ_CONTENT_TYPE" != "" && "$_REQ_CONTENT" == "" ]]; then
        error "Cannot use --content-type without --content"
    fi
    if [ "$_REQ_CONTENT" != "" ]; then
        if [ ! -f "$_REQ_CONTENT" ]; then
           error "Cannot access file $_REQ_CONTENT"
        fi
        _CONT="cat '$_REQ_CONTENT' | "
        _CONTL="export CONTENT_LENGTH=\$(stat -c%s '$_REQ_CONTENT')"
        if [ "$_REQ_CONTENT_TYPE" != "" ]; then
            _CONTT="export CONTENT_TYPE='$_REQ_CONTENT_TYPE'"
        fi
    else
        _CONTL="export CONTENT_LENGTH="
    fi
    echo "$_CONTT
$_CONTL
$_SHEADER
export REQUEST_METHOD=$_REQ_METHOD
export SCRIPT_NAME=\"$_APATH\"
export PATH_INFO=\"$_REQ_PATH\"
export QUERY_STRING=\"$_REQ_QUERY\""> $_TOEXEC
    if [ "$_REQ_SRV" == "1" ]; then
        if [[ "$_REQ_IP" != "" && "$_REQ_SOCK" != "" ]]; then
            error "Cannot use both --remote and --socket"
        fi
        if [ "$_REQ_IP" != "" ]; then
            echo "${_CONT}"$GG_LIBRARY_PATH"/ggcli \"$_REQ_IP\"" >> $_TOEXEC 
        else
            if [ "$_REQ_SOCK" != "" ]; then
                if [ ! -S "$_REQ_SOCK" ]; then
                    error "Cannot access socket $_REQ_SOCK or is not a socket file"
                fi
                echo "${_CONT}"$GG_LIBRARY_PATH"/ggcli $_REQ_SOCK" >> $_TOEXEC 
            else
                echo "${_CONT}"$GG_LIBRARY_PATH"/ggcli $GG_DATA/apps/$_ANAME/sock/.sock" >> $_TOEXEC 
            fi
        fi
    else
        if [[ "$_REQ_IP" != "" || "$_REQ_SOCK" != "" ]]; then
            error "Cannot use --remote or --socket without --service"
        fi
        #add arguments if specified for command-line run
        ADD_ARG=""
        if [ "$_REQ_ARG" != "" ]; then
            IFS=' ' read -r -a ADD_ARG <<< "$_REQ_ARG"
        fi
        echo -n "${_CONT}$GG_DATA/apps/$_ANAME/.bld/$_ANAME" >> $_TOEXEC 
        if [ "$_REQ_ARG" != "" ]; then
            ARG_LEN=${#ADD_ARG[@]}
            for (( i=0; i<$ARG_LEN; i++ )); do
                echo -n " '${ADD_ARG[$i]}'" >> $_TOEXEC
            done
        fi
        echo "" >> $_TOEXEC 
    fi
    if [[ "$_REQ_EXEC" == "1" && "$_REQ_URL" == "" ]]; then
        error "Cannot use --exec without --req"
    fi
    if [ "$_REQ_EXEC" == "1" ]; then
       chmod +x $_TOEXEC
       RCODE=0
       . $_TOEXEC || RCODE=$?
       if [ "$RCODE" != "0" ]; then
           exit_s $RCODE
       fi
    else
        cat $_TOEXEC
    fi
}



#
#
#
#Show last $1 errors from backtrace
#
#
#
function showerr() {
    #accounts for too many files
    ERRF=$(find $GG_DATA/apps/$GG_C_NAME/trace/ -maxdepth 1 -name "bt*" -type f -printf '%T@ %p\n' | sort -k1,1nr |  awk '{print $2}'| head -$1)
    if [ "$ERRF" != "" ]; then
        for i in $ERRF; do
            echo "******* File: $i"
            cat $i
            echo ""
        done
    fi
}

#
#
#
#Get database vendors and names from dbvendor:dbname ... format, which is the input ($1)
#
#
#
function getdbs() {
#database vendor/name pairs

    _DBL="$1"
    _j=0
    for _i in $_DBL; do
#-n says do not print non-matches, p says print matches only
        _DBV[$_j]=$(sed -n 's/\(.*\):\(.*\)/\1/p' <<<$_i)
        _DBN[$_j]=$(sed -n 's/\(.*\):\(.*\)/\2/p' <<<$_i)
        if [[ "${_DBV[$_j]}" != "mariadb" && "${_DBV[$_j]}" != "postgres" && "${_DBV[$_j]}" != "sqlite" ]]; then
            error "Database [${_DBV[$_j]}] is not supported (specify database as vendor:database_name, and in case of multiple databases separated them with a space in a quoted value)"
        fi
        if [ "${_DBN[$_j]}" == "" ]; then
            error "Database configuration file not specified"
        fi
        if [[ ! "$_DBVALL" =~ " ${_DBV[$_j]} " ]]; then
            _DBVALL="$_DBVALL ${_DBV[$_j]} "
        fi
        ((_j=_j+1))
    done
}

#
#
#
#Autocreate settings file used to recompile if one (or more) of them changes
#File $GG_BLD/blds is used in vmakefile as a signal to recompile all (if changed)
#Sole purpose is to know when to recompile, nothing is cached as far as command-line params go.
#
#GG_C_MAXERRORS does not affect compilation, only the output of errors, so not
#part of mkset.
#
#
function mkset() {
    echo "GG_C_SKIPLINES='$GG_C_SKIPLINES'
GG_C_ASAN='$GG_C_ASAN'
GG_C_PROF='$GG_C_PROF'
GG_C_IGNORE_WARN='$GG_C_IGNORE_WARN'
GG_C_SHOW='$GG_C_SHOW'
GG_C_GCC='$GG_C_GCC'
GG_C_DEVEL='$GG_C_DEVEL'
GG_C_DEBUG='$GG_C_DEBUG'
GG_C_PUBLIC='$GG_C_PUBLIC'
GG_C_SINGLE_FILE='$GG_C_SINGLE_FILE'
GG_C_MAXUPLOAD='$GG_C_MAXUPLOAD'
GG_C_CLIENT_TOUT='$GG_C_CLIENT_TOUT'
GG_C_RESTPATH='$GG_C_RESTPATH'
GG_C_CFLAGS='$GG_C_CFLAGS'
GG_C_LFLAGS='$GG_C_LFLAGS'
GG_C_LFLAGS='$GG_C_LFLAGS'
GG_C_POSIXREGEX='$GG_C_POSIXREGEX'
GG_C_V1_MOD='$(stat -c "%Y" $GG_LIBRARY_PATH/v1)'
GG_C_GG_MOD='$(stat -c "%Y" $(which gg))'
GG_DBS='$_ALLDB'
" > $GG_BLD/.blds
    if [ ! -f "$GG_BLD/blds" ]; then
        cp -f $GG_BLD/.blds $GG_BLD/blds
    else
        _ECODE="0"
        diff $GG_BLD/.blds $GG_BLD/blds > /dev/null || _ECODE="$?"
        if [ "$_ECODE" != 0 ]; then
            cp -f $GG_BLD/.blds $GG_BLD/blds
        fi
    fi
}


#
#
#
#Show documentation directory
#
#
#
function docdir() {
    echo "$GG_DATA/golf"
}

#
#
#
#Check if app name is valid
#
#
#
function check_name() {
#$1 is the name
#$2 is the type of it (used in error message)
    if [[ ! "$1" =~ ^[-a-zA-Z0-9_]{1,30}$ ]]; then
        error "$2 name can be made up of alphanumerical characters only, hyphen or underscore, and its length must be between 1 and 30 characters, found [$1]"
    fi
}






#
#
#Discovery of what's installed and prepare for build to minimize use of includes and libs
#
#
function read_modules() {
#
    #begin automatic libs discovery
    #release name
    export GG_REL_NAME=
    #includes
    export GG_MARIADB_INC=
    export GG_SQLITE_INC=
    export GG_CURL_INC=
    export GG_PCRE2_INC=
    export GG_CRYPTO_INC=
    export GG_POSTGRES_INC=
    export GG_XML_INC=
    #
    #do libs exist or not
    export GG_MARIADB_EX=
    export GG_SQLITE_EX=
    export GG_CURL_EX=
    export GG_PCRE2_EX=
    export GG_CRYPTO_EX=
    export GG_POSTGRES_EX=
    export GG_XML_EX=
    #golf libs
    export GG_MARIADB_LIB_S=
    export GG_SQLITE_LIB_S=
    export GG_CURL_LIB_S=
    export GG_PCRE2_LIB_S=
    export GG_CRYPTO_LIB_S=
    export GG_POSTGRES_LIB_S=
    export GG_XML_LIB_S=
    #install instructions
    export GG_XML_INSTALL=
    export GG_MARIADB_INSTALL=
    export GG_SQLITE_INSTALL=
    export GG_CURL_INSTALL=
    export GG_PCRE2_INSTALL=
    export GG_CRYPTO_INSTALL=
    export GG_POSTGRES_INSTALL=
    #package names
    export GG_XML_PACKAGE=
    export GG_MARIADB_PACKAGE=
    export GG_SQLITE_PACKAGE=
    export GG_CURL_PACKAGE=
    export GG_PCRE2_PACKAGE=
    export GG_CRYPTO_PACKAGE=
    export GG_POSTGRES_PACKAGE=
    #3rd party libs
    export GG_XML_LIB=
    export GG_MARIADB_LIB=
    export GG_SQLITE_LIB=
    export GG_CURL_LIB=
    export GG_PCRE2_LIB=
    export GG_CRYPTO_LIB=
    export GG_POSTGRES_LIB=
    #determine library existance
    . $GG_BIN_PATH/gglib 
    #make all include paths available if needed (we only include those actually used so not to waste time processing .h files we don't need)
    export GG_ALL_INCLUDE="$GG_MARIADB_INC $GG_SQLITE_INC $GG_CURL_INC $GG_PCRE2_INC $GG_CRYPTO_INC $GG_POSTGRES_INC $GG_XML_INC"
    #delete mod files, set by v1 to determine which libs are actually used by Golf application
    rm -f $GG_BLD/.mod.*
    #
    #end automatic libs discovery
    #used in vmakecommon/install to properly link modules at link-time and to substitute stubs for those modules that are not used
    #
}

#
#
#
#make generated files affect recompilation ONLY if they are different
#
#
#
function copy_if_diff () {
    F="$1"
    _ISDIFF=$(diff $GG_BLD/$F.new $GG_BLD/$F 2>/dev/null) || true
    if [[ "$_ISDIFF" != "" || ! -f "$GG_BLD/$F" ]]; then
        mv $GG_BLD/$F.new $GG_BLD/$F
    else
        rm -rf $GG_BLD/$F.new
    fi
}



#
#
#sets a list of many source code files (source.golf, golfapp.h, gg_dispatch_request.c etc.)
#takes care of generated vs provided source code: if a certain handler is provided, then don't generate it.
#
#
function gen_src() {
    [[ "$GG_C_SHOW" == "1" ]] && echo "golf: Analyzing source files."

#
#Files generated here are $GG_BLD/source.golf,golfapp.h,gg_dispatch_request.c.
#

#
#Setup directory for set-param'eters where all parameter names for application will go to
#
    if [ ! -d $GG_BLD/.setparam ]; then
        rm -rf $GG_BLD/.setparam || true
        mkdir -p $GG_BLD/.setparam
    fi

#
#Setup directory for where we record all request handlers called and who called them
#
    if [ ! -d $GG_BLD/.calledreq ]; then
        rm -rf $GG_BLD/.calledreq || true
        mkdir -p $GG_BLD/.calledreq
    fi


#
#Generate source.golf, all the source files needed for Golf app
#
    _T="source.golf"
#this is all source files, including C files
#
    GG_CLIST_A=(*.c) 2>/dev/null || true # this is an array
    GG_CLIST=${GG_CLIST_A[*]} # this is a string
#
    GG_GOLFLIST_A=(*.golf) 2>/dev/null || true
    GG_GOLFLIST=${GG_GOLFLIST_A[*]}
#
    GG_HLIST_A=(*.h) 2>/dev/null || true
    GG_HLIST=${GG_HLIST_A[*]}
#
#GG_REQLIST is really a list of requests, which we get from the list of source files
#GG_GOLFLIST is the list of golf files - note these are "flattened" so that any directory structure works in a flat directory with / substituted for __
    GG_REQLIST=""
    GG_REQLIST_C=0
    for i in $GG_GOLFLIST; do
#we can do this since we prohibit line splitting for begin-handler or %%
        RS=$(sed -n 's/^\s*\(%%\|begin\-handler\) \s*\([^ \t]\+\).*/\2/gp' $i)
        for OF in $RS; do #take request paths and turn them into flat files
            OF=${OF/#\//}
            OF=${OF//\//__}
            GG_REQLIST="$GG_REQLIST
$OF"
            ((GG_REQLIST_C=GG_REQLIST_C+1))
        done
    done

    echo "#SPDX-License-Identifier: Apache-2.0" >> $GG_BLD/$_T.new
    echo "#Copyright 2018-2025 Gliim LLC. " >> $GG_BLD/$_T.new
    echo >> $GG_BLD/$_T.new
    echo "#" >> $GG_BLD/$_T.new
    echo "#Lists source files in your application. This is an auto-generated file." >> $GG_BLD/$_T.new
    echo "#" >> $GG_BLD/$_T.new
    echo >> $GG_BLD/$_T.new
    echo "#Include files here:" >> $GG_BLD/$_T.new
    _HFILES=$(grep -a -v golfapp.h <<<"$GG_HLIST" | xargs)
    echo "GG_HEADER_FILES=$(echo $_HFILES)" >> $GG_BLD/$_T.new
    echo >> $GG_BLD/$_T.new
    echo "#Source files here:" >> $GG_BLD/$_T.new
    echo "GG_SOURCE_FILES=$(echo $GG_GOLFLIST)" >> $GG_BLD/$_T.new
    echo "GG_SOURCE_C_FILES=$(echo $GG_CLIST)" >> $GG_BLD/$_T.new

    _ISDIFF=$(diff $GG_BLD/$_T.new $GG_BLD/$_T 2>/dev/null) || true
    if [[ "$_ISDIFF" != "" || ! -f "$GG_BLD/$_T" ]]; then
        mv $GG_BLD/$_T.new $GG_BLD/$_T
    else
        rm -rf $GG_BLD/$_T.new
    fi



#
#Generate golfapp.h, a file that has a list of C declarations neeeded to build an app
#
    _T="golfapp.h"

    echo "// SPDX-License-Identifier: Apache-2.0"  >> $GG_BLD/$_T.new
    echo "// Copyright 2018-2025 Gliim LLC. ">> $GG_BLD/$_T.new
    echo >> $GG_BLD/$_T.new
    echo "// This is an auto-generated file for a GOLF application" >> $GG_BLD/$_T.new
    echo >> $GG_BLD/$_T.new
    echo "#ifndef _GOLFAPP" >> $GG_BLD/$_T.new
    echo "#define _GOLFAPP" >> $GG_BLD/$_T.new
    echo >> $GG_BLD/$_T.new
    if [ "$_HFILES" != "" ]; then
        for i in $_HFILES; do
            sed 's/\(.*\)/#include "\1"/g' <<< $i >> $GG_BLD/$_T.new
        done
        echo >> $GG_BLD/$_T.new
    fi
    echo "// function prototypes of your code" >> $GG_BLD/$_T.new
#declare all functions, including non-request ones (whether implemented or not)
    for _F in $GG_REQLIST; do
        RN=${_F%.*}
        #function name cannot have -
        RN=${RN//-/_}
        #if main, cannot have that, since we have main() already. Must delete $_T.new in order to regenerate, otherwise main would remain
        #NOTE: if updating here, update in v1.c in is_reserved()
        CC_KEYS=" auto break bool case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while main "
        if [[ " $CC_KEYS " =~ .*\ $RN\ .* ]]; then
            rm -f $GG_BLD/$_T.new 
            error "Service handler name cannot be a C reserved word [$RN]"
        fi
        echo "gg_num ${RN}();" >> $GG_BLD/$_T.new
    done
    echo >> $GG_BLD/$_T.new
    echo "#endif" >> $GG_BLD/$_T.new

    #if newly generated file is the same as the old one, don't touch the old one in order to
    #prevent recompilation needlessly
    _ISDIFF=$(diff $GG_BLD/$_T.new $GG_BLD/$_T 2>/dev/null) || true
    if [[ "$_ISDIFF" != "" || ! -f "$GG_BLD/$_T" ]]; then
        mv $GG_BLD/$_T.new $GG_BLD/$_T
    else
        rm -rf $GG_BLD/$_T.new
    fi

#
#Generate gg_dispatch_request.c, the main request handler. Based on the source code names of handler files (.golf files)
#
    _T=".flatsrc/gg_dispatch_request.c"
#Generate request files, this is used for a dispatcher
#and for a dispatcher, only request files matter 
    if [ "$GG_REQLIST_C" == "0" ]; then
        error "Application must have at least one .golf file, or no begin-handler (or %%) statements found"
    fi

    echo "// SPDX-License-Identifier: Apache-2.0" >>$GG_BLD/$_T.new
    echo "// Copyright 2018-2025 Gliim LLC. " >>$GG_BLD/$_T.new
    echo >>$GG_BLD/$_T.new
    echo "// GOLF auto-generated request dispatcher" >>$GG_BLD/$_T.new
    echo >>$GG_BLD/$_T.new
    echo "#include \"golf.h\"" >>$GG_BLD/$_T.new
    echo "void gg_dispatch_request() {" >>$GG_BLD/$_T.new


#req_done used to skip before/after execution if no handler used
    echo "    volatile int req_done;" >>$GG_BLD/$_T.new #volatile because of longjmp, so the init below doesn't get optimized

    if [ "$GG_REQLIST_C" != "0" ]; then
        echo "    char *req=gg_get_config()->ctx.req->name;" >>$GG_BLD/$_T.new
    fi
    #
    # Setting up longjmp must be done after ANY local variables are established so they are not lost after any exit-handler
    # or errors. This is because stack pointer after sigsetjmp will be LOST. So all local vars definitions must be PRIOR to it
    #
#longjmp for when a request exits via exit-handler. If return value is <>0, it means
#this is a call from longjmp, and we should proceed to right after gg_dispatch_request - that is the extent
#of unwinding, such that we rollback uncommitted transactions, shutdown request and release all memory and
#then move on to the next request.
#Cannot place setjmp within if, may not process correctly when jump happens.
#We use gg_done_setjmp to prohibit exit-handler from executing the jump unless sigsetjmp was done first at runtime.
    echo "    int ret_val = sigsetjmp(gg_jmp_buffer, 1);" >>$GG_BLD/$_T.new
    echo "    if (ret_val != 0) goto end_point_exit;" >>$GG_BLD/$_T.new
    echo "    gg_done_setjmp = 1;" >>$GG_BLD/$_T.new
#right now the return value is always 0 (directly or called from longjmp)
#the jump will work because all we do is go to after_handler() function, which doesn't depend on any
#automatic variables from gg_dispatch_request, and after that function exits
#
#
#
    echo "    req_done = 0;" >>$GG_BLD/$_T.new #must be initialized separately (not as int req_done=0;) because longjmp may return to the same function and won't be initialized again
#create file with all request names for v1 to process for the main function code. This way all request info is stored as constants to be loaded as program's data, meaning the fastest possible in huge memory blocks, without having to set up each individually
#first line is the number of lines that follow, to make code generation easier
    echo $GG_REQLIST_C > $GG_BLD/.reqlist.new
    _F_FIRST=""
    for _F in $GG_REQLIST; do
        RN=${_F%.*}
        #function name cannot have -
        RN=${RN//-/_}
        if [ "$_F_FIRST" == "" ]; then _F_FIRST="$RN"; fi
        echo "$RN" >>$GG_BLD/.reqlist.new
    done
    echo "  gg_request_handler _gg_req_handler;" >>$GG_BLD/$_T.new
    echo "  gg_num found = GG_OKAY;" >>$GG_BLD/$_T.new
    #if only a single request, speed things up by checking simply if that's the one, and run it (i.e. do not call gg_find_hash)
    if [ "$GG_REQLIST_C" == "1" ]; then
        echo "    if (!strcmp (req, \"$_F_FIRST\") || req[0] == 0) _gg_req_handler = $_F_FIRST; else found = GG_ERR_EXIST;" >>$GG_BLD/$_T.new
    else
#get handler function that handles this request from the pre-computed hash. Both what's in gg_dispatch and req are NOT golf mem, so false for is_golf memory
        echo "    _gg_req_handler = gg_find_hash (&gg_dispatch, req, 0, &found, false);" >>$GG_BLD/$_T.new
    fi
#before handler executes only IF req found a handler, that's why it's not in front of if()
    echo "      if (found == GG_OKAY) {" >>$GG_BLD/$_T.new
    echo "        before_handler();" >>$GG_BLD/$_T.new
    echo "        req_done = 1;" >>$GG_BLD/$_T.new
    echo "        _gg_req_handler();" >>$GG_BLD/$_T.new
    echo "    } else {" >>$GG_BLD/$_T.new
    echo "        gg_bad_request();" >>$GG_BLD/$_T.new
    echo "        gg_replace_string (req, strlen(req), \"__\", \"/\", 1, NULL, 1);" >>$GG_BLD/$_T.new # subst makes for smaller string, so okay, this is to show proper path in error
    echo "        gg_report_error (\"Request [%s] not found\", req);" >>$GG_BLD/$_T.new
    echo "    }" >>$GG_BLD/$_T.new

#when exit-handler is done, this is where we must end up. Since this code is executed after
#gg_dispatch_request, we can't longjump here. We long jump to a prior point and then go to here.
    echo "end_point_exit:" >>$GG_BLD/$_T.new
#set gg_done_setjmp to 0, because if we do exit-handler in after_handler(), it would go into infinite loop, coming back to after.
#this way, exit-handler in after_handler, or anywhere afterwards, will do nothing. Only when the next request comes along, and gg_done_setjmp is set to 1
#in the beginning of this function, we will actually jump to end_point_exit:
    echo "    gg_done_setjmp = 0;" >>$GG_BLD/$_T.new
#regardless of whether a request normally ended, or had exit-handler, it would come here, and before anything else, memory handling must be set back
#to Golf, or otherwise, and gg_* memory function will fail if set to true. after_handler() should not be affected by type of memory used.

#cannot do exit-handler in after_handler - must simply do return(s)
    echo "    if (req_done == 1) { after_handler(); }" >>$GG_BLD/$_T.new
#
#There can be NOTHING after .after() that uses any automatic variables from gg_dispatch_request() or
#exit-handler (and longjmp) will not work
#
    echo "}" >>$GG_BLD/$_T.new
    echo >>$GG_BLD/$_T.new

    copy_if_diff "$_T"
    copy_if_diff ".reqlist"
}



#
#
#
#Create linkage for before,after events. _weak_ linkage didn't work because Golf should produce
#a program that links *only* with Golf libs. It means we only distribute a single file, which is a program,
#that has only the minimal set of code - and this program uses Golf's shared library. Hence, all is shared 
#(the program between different instance and all the shared libs).
#GG_EVENT_STUBS is all the stubs used.
#So, GG_EVENT_STUBS could be "$GG_DEST/golf/stub_after.o" but then available after vmakefile will be "$GG_BLD/before_handler.o"
#and all three will be present (one empty and two implemented)
#
#
#
function stub_events() {
    GG_EVENT_STUBS=
    if [ ! -f "before-handler.golf" ]; then
        GG_EVENT_STUBS="$GG_EVENT_STUBS $GG_LIBRARY_PATH/$GDEST/stub_before.o"
    fi
    if [ ! -f "after-handler.golf" ]; then
        GG_EVENT_STUBS="$GG_EVENT_STUBS $GG_LIBRARY_PATH/$GDEST/stub_after.o"
    fi
    export GG_EVENT_STUBS
}


#
#
#
#Turn path-based source into a flat __ based source files 
#Cannot remove and then copy b/c this would cause make to re-make all files
#each time since their timestamp would change. So we must use -p flag of cp
#to preserve source file's timestamps.
#This converts x/y/z into x__y__z files and a-b.golf into a_b.golf
#So we can do full path URL based structure and "flatten" it as it
#always was prior to this
#
#
#
function flatten_source() {
#directory where we build is .flatsrc
    if [ "$GG_DIR_EXCLUDE" != "" ]; then
        #make a list of directories we can iterate over, it's decorated as well so we can easily compare with
        #eligible files
        GG_DIR_EXCLUDE_F=${GG_DIR_EXCLUDE//,/ }
    fi


#delete all, b/c what happens when renaming, deleting files - they
#would still hang in .flatsrc directory, and we can copy without recompiling
#if no changes, because we use ln -s which preserves timestamps for make
    rm -rf $GG_BLD/.flatsrc
    mkdir -p $GG_BLD/.flatsrc

#use find, with maxdepth of 1 for flat dir
    F0=(*) 2>/dev/null || true
    F1=(**/*) 2>/dev/null || true
    F0+=("${F1[@]}")
    for i in "${F0[@]}"; do
        if [ -f "$i" ]; then 
            i="./$i"
#for each file remove leading ./, then convert all / to __ and
#all - to _
            OF=${i/#\.\//}
            EXCL=0
            for k in $GG_DIR_EXCLUDE_F; do
                k="${k}/"
                if [[ "$OF" == "$k"* ]]; then
                    EXCL=1
                    break
                fi
            done
            if [ "$EXCL" == "1" ]; then continue; fi
            OF=${OF//\//__}
            ln -s $PWD/$i $GG_BLD/.flatsrc/$OF 2>/dev/null || true
        fi
    done
#make sure app name is there too, || true is b/c find will find it and it will exist
#    ln -s .vappname $GG_BLD/.flatsrc || true
}


#
#
#
#Build Golf app
#
#
#
function build_app() {
    if [ ! -d $GG_BLD ]; then
        error "Application does not exist, use 'gg -k' to create it"
    fi
    [[ "$GG_C_SHOW" == "1" ]] && echo "golf: Gathering source files."
    flatten_source

#once source is flattened, go there, but in a new shell ()
#so we can switch to .flatsrc directory, and no matter where this 
#compilation ends, we end up in current dir after it's done, because
#were' in subshell
#save current working directory, it's needed as -srcdir param to v1
    ECODE=0 #necessary for ECODE to work below (because if there's no error then ECODE=$? never runs and ECODE is undefined
    ( 
    export GG_CDIR="$PWD"
    cd $GG_BLD/.flatsrc
    _VFILES_A=(*.golf) 2>/dev/null || true
    _VFILES=${_VFILES_A[*]}
    if [ "$_VFILES" == "0" ]; then error "Your application must have at least one .golf file"; fi
#set .dbvendors for v1 to pickup
    db_lib
#get any modules in use, and generate a list of all modules
    read_modules
#generate needed source code
    gen_src
#generate stubs (if needed) for events (before, after)
    stub_events
#create file that tells make to recompile if options changed
    mkset
#check if any libs installed changed (added or removed). Just upgrade/downgrade doesn't count
#Note this GGLIBS must match what' recorded in Makefile exactly (order and all)
    GGLIBS="GG_MARIADB_EX='$GG_MARIADB_EX';GG_SQLITE_EX='$GG_SQLITE_EX';GG_CURL_EX='$GG_CURL_EX';GG_PCRE2_EX='$GG_PCRE2_EX';GG_CRYPTO_EX='$GG_CRYPTO_EX';GG_POSTGRES_EX='$GG_POSTGRES_EX';GG_XML_EX='$GG_XML_EX'"
    if [ -f "$GG_DATA/golf/.golf.libs" ]; then
        read -r -d '' GGLIBS_OLD < $GG_DATA/golf/.golf.libs
    else
        GGLIBS_OLD=
    fi
    if [[ "$GGLIBS_OLD"  != "$GGLIBS" ]]; then
        echo "Recompiling Golf objects due to change in installed libraries; this happens only when libraries used by Golf are installed or removed. Please wait for it to complete." 
        CDIR="$PWD"
        tar xvfz $GG_DATA/golf/golf.tar.gz -C $GG_DATA/golf/src/ >/dev/null
        cd $GG_DATA/golf/src
        make clean 
        make -j $(nproc) 
        make install DESTDIR=$GG_DATA 
        echo "$GGLIBS" > $GG_DATA/golf/.golf.libs
        echo "Golf objects recompiled, continuing."
        cd $CDIR
    fi
#check if gcc version has changed, it means we need to recompile LTO from /golf/src
#changing gcc version would make project recompile since GG_C_GCC is part of mkset()
#Note this GG_C_GCC must match what' recorded in Makefile exactly 
    if [ -f "$GG_DATA/golf/.golf.gcc" ]; then
        read -r -d '' GG_CHECK_GCC < $GG_DATA/golf/.golf.gcc
    else
        GG_CHECK_GCC=
    fi
    #if we want release and it's not built yet
    if [[ "$GG_C_DEVEL" == "0" && "$GG_C_GCC"  != "$GG_CHECK_GCC" ]]; then
        #
        #this should NOT run in subshell because we want to exit if there's an error here!
        #
        echo "Recompiling Golf LTO objects; this happens only when gcc version changes or the first time release is made. Please wait for it to complete." 
        CDIR="$PWD"
        tar xvfz $GG_DATA/golf/golf.tar.gz -C $GG_DATA/golf/src/ >/dev/null
        cd $GG_DATA/golf/src
        make clean 
        make -j $(nproc) REL=1
        make install DESTDIR=$GG_DATA REL=1
        echo "$GG_C_GCC" > $GG_DATA/golf/.golf.gcc 
        echo "Golf LTO objects recompiled, continuing."
        cd $CDIR
    fi


#make the application (compile and link) in parallel
#if GG_SHOW_MAKE is not "-s", then it's not silent, and display what it's doing
#otherwise use -s for silent
#We ignore return code from vmakefile (and make it exit 0 when we exit), we though check if there's anything in standard error!
#This makes gnu make quiet, so we don't get useless message that some rule failed; we already know that if there's an error output
#All output from vmakefile that's relevant to Golf is prefixed with 'golf: ', so we filter out anything else.
    make -j$GG_C_CPUS $GG_SHOW_MAKE -f "$GG_LIBRARY_PATH"/vmakefile all 2>$GG_BLD/.make.output 
    ) || ECODE=$? 
    if [ "$ECODE" == "0" ]; then
        if [ "$GG_C_SHOW" == "1" ]; then
            if [ "$GG_C_DEVEL" == "0" ]; then
                echo "golf: Made RELEASE executables"
            else
                echo "golf: Made DEVEL executables"
                if [ "$GG_C_DEBUG" == "1" ]; then
                    echo "golf: Added DEBUG code"
                fi
            fi
        fi
    else
        #without || true here, our trap (see beginning of gg) will cause ugly (and useless) message
        cat $GG_BLD/.make.output|grep 'golf: ' | grep -v "^make:" |sed 's/__/\//g' 1>&2 || true
        echo "There are errors in making your application (complete log at $GG_BLD/.make.output)."
    fi
    exit_s $ECODE
}

#
#
#
#Command line options implementation
#
#
#

function gg_version() {
#the final year is based on the year when the last Makefile ran, which is a pretty good indicator of when was the last change done here by the author;
#of course, for those who compile from source, and don't use the provided deb/dnf packages, it will always be the current year - that is not the intention -
#in that case, change this manually to the year from the official distribution!!!! That is required under most copyright laws, in which the second year should
#be the year of the last change by the author.
    echo "Golf $GG_VERSION$_BETA on $GG_PLATFORM_ID ($GG_PLATFORM_VERSION). Copyright (c) 2018-$(date '+%Y') Gliim LLC. Golf uses other libraries, including OpenSSL, SQLite, Postgres, MariaDB, PCRE2, Curl, LibXML2, FastCGI, Libbacktrace. See "license" documentation page for acknowledgements and the full list (on the web or 'gg --man license' from command line)."

}

#
#
#
#display file or empty string if it doesn't exist
#
#
#
function cat0() {
    if [ ! -f "$1" ]; then echo ""; else cat "$1"; fi
}



#
#
#
#Quick auto app maker
#
#
#
function autoapp() {

    build_app 
    exit 0
}


#
#
#
#Set library modules from --db. Either db_lib (-q) or init_db (-qa) is executed, but not both
#
#
#
function db_lib() {
#parse --db input
#get list of dbs - add any new db vendors here (currently mariadb and postgres)
    rm -f $GG_BLD/.dbvendors
    getdbs "$_ALLDB"
    _TOTDB="${#_DBV[@]}"
    for (( _i=0; _i<$_TOTDB; _i++ )); do
#must copy array element 
        _DBNAME="${_DBN[$_i]}"
        _DBCONF="$_DBNAME"
#build list of all
        _ALLC="$_ALLC
$_DBCONF"
        _DBMAKE="${_DBV[$_i]}"
        if [ "$_DBMAKE" == "sqlite" ]; then
            if [ "$_DONELITE" == "" ]; then
                _DONELITE="1"
            fi    
#for v1.c to pick up
            echo "${_DBCONF}=sqlite" >> $GG_BLD/.dbvendors
            if [ ! -f "$_DBCONF" ]; then
                error "Database configuration file [$_DBCONF] ($_DBMAKE) not found"
            fi
            "$GG_LIBRARY_PATH"/v1 -envsub < "$_DBCONF" > $GG_H/db/"$_DBCONF"
        fi
        if [ "$_DBMAKE" == "mariadb" ]; then
            if [ "$_DONEMARIA" == "" ]; then
                _DONEMARIA="1"
            fi    
#for v1.c to pick up
            echo "${_DBCONF}=mariadb" >> $GG_BLD/.dbvendors
            if [ ! -f "$_DBCONF" ]; then
                error "Database configuration file [$_DBCONF] ($_DBMAKE) not found"
            fi
            "$GG_LIBRARY_PATH"/v1 -envsub < "$_DBCONF" > $GG_H/db/"$_DBCONF"
        fi
        if [ "$_DBMAKE" == "postgres" ]; then
            if [ "$_DONEPG" == "" ]; then
                _DONEPG="1"
            fi
#for v1.c to pick up
            echo "${_DBCONF}=postgres" >> $GG_BLD/.dbvendors
            if [ ! -f "$_DBCONF" ]; then
                error "Database configuration file [$_DBCONF] ($_DBMAKE) not found"
            fi
            "$GG_LIBRARY_PATH"/v1 -envsub < "$_DBCONF" > $GG_H/db/"$_DBCONF"
        fi
    done
#check db conf name unique
    _TUNIQ=$(echo $_ALLC|sort -k 1|uniq|wc -l)
    _TOT=$(echo $_ALLC|wc -l)
    if [ "$_TUNIQ" != "$_TOT" ]; then
        error "Database configuration names must be unique"
    fi
}



#
#
#
#Clean building artifacts of Golf code to rebuilt it entirely
#
#
#
function gg_clean() {
#clean the source and other code, so the next golf app compilation will be a full rebuild
    make $GG_SHOW_MAKE -f "$GG_LIBRARY_PATH"/vmakefile clean
}


main "$@"



